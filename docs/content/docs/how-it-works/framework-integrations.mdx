---
title: Framework Integrations
---

# Framework Integrations

<Callout>
  The goal for Workflow DevKit is to have official adapters for everywhere you
  need to run workflows. Go to the [getting started](/docs/getting-started)
  guide to pick your framework and get started.
</Callout>

If you're interested in learning how Workflow integrates with frameworks and how you can build your own adapter, read on. We'll walk through building the Bun adapter together and explain the underlying architecture of how the Workflow DevKit integrates with different JavaScript runtimes. While this example uses Bun, the same principles apply to writing adapters for any JavaScript runtime (Node.js, Deno, Cloudflare Workers, etc.).

---

## Overview

The Workflow DevKit architecture is as follows:

1. **Build-time transformation**: Workflow code is transformed by a framework agnostic compiler plugin
2. **Generated handlers**: The build process generates HTTP handlers in `.well-known/workflow/v1/` bundled with your step, workflow, and webhook code
3. **Runtime integration**: Your application server exposes these handlers as HTTP endpoints ([learn about how security is handled](#security))
4. **Execution orchestration**: The Workflow DevKit communicates with these endpoints to orchestrate durable execution

```mermaid
flowchart TD
    A["Source Code<br/>'use workflow'"] --> B["SWC Transform<br/>(Build Plugin)"]
    B --> C["Generated Files<br/>flow.js/step.js"]
    C --> D["HTTP Server<br/>(Your Runtime)"]
```

---

## The Transformation Pipeline

### 1. Source Code Directives

Workflows use special directives to mark code for transformation:

```typescript
export async function handleUserSignup(email: string) {
  "use workflow";

  const user = await createUser(email);
  await sendWelcomeEmail(user);

  return { userId: user.id };
}

async function createUser(email: string) {
  "use step";

  return { id: crypto.randomUUID(), email };
}
```

**Key directives:**

- `"use workflow"`: Marks a function as a durable workflow entry point
- `"use step"`: Marks a function as an atomic, retryable step

### 2. Build-Time Transformation

The `@workflow/swc-plugin` transforms these functions into instrumented code that:

- Captures function calls and their arguments
- Generates serialization/deserialization logic
- Creates step boundaries for durability
- Produces execution graphs

When you run `workflow build`, the framework adapter:

1. Scans directories where the framework's source code typically lives (for example, `app/` or `pages/` in Next.js)
2. Transforms files containing workflow directives
3. Generates handler files for the framework to expose at `.well-known/workflow/v1/*`

```json
{
  "buildTarget": "vercel-build-output-api",
  "dirs": ["workflows"]
}
```

<Callout type="info">
  **No Vendor Lock-In**: `workflow build` is completely agnostic from the world
  abstraction and runtime environment. It outputs standard JavaScript HTTP
  handler code that works anywhere. This separation means you can deploy your
  workflows to any JavaScript runtime without being locked into a specific
  platform or provider.
</Callout>

### 3. Generated Artifacts

The build process creates two critical files:

- **`.well-known/workflow/v1/flow.js`**: Handles workflow execution requests
- **`.well-known/workflow/v1/step.js`**: Handles individual step execution requests

These files export handlers for POST requests that take in the web standard `Request` object.

---

## Required HTTP Endpoints

Your runtime adapter must expose these two endpoints:

### `POST /.well-known/workflow/v1/flow`

Executes workflow-level operations (starting workflows, resuming after steps).

**Request**: Binary payload from Workflow DevKit
**Response**: Binary payload with execution results

### `POST /.well-known/workflow/v1/step`

Executes individual steps within workflows.

**Request**: Binary payload from Workflow DevKit
**Response**: Binary payload with step results

The exact protocol is handled by the generated `flow.js` and `step.js` files. Your adapter just needs to route HTTP requests to these handlers.

---

## Security

A natural question when exposing these HTTP endpoints is: how are they secured?

The answer depends on the **world abstraction** you're using. Different world implementations provide different security mechanisms:

### World-Specific Security

**Vercel (via `@workflow/world-vercel`):**

- Uses Vercel Queue as the backend orchestration layer
- Vercel Queue will soon support **private invoke**, making these routes not publicly accessible from the internet
- The handler receives only a **message ID** from the queue, which must be retrieved from the Vercel Queue backend
- This architecture makes it impossible to craft custom payloads and directly invoke the endpoints with arbitrary data
- Even if someone discovers the endpoint URL, they cannot execute workflows without valid message IDs from the queue system

**Custom Implementations:**

- Different world implementations can implement their own security measures
- Framework middleware can add authentication and authorization layers
- You can implement API key verification, JWT validation, or other authentication schemes
- You can use network-level security (VPCs, private networks, firewall rules)
- You can implement rate limiting and request validation

### Best Practices

When building your own world or adapter, consider:

- **Authentication**: Verify that requests come from trusted sources (your orchestration backend, not external clients)
- **Payload validation**: Ensure request payloads are cryptographically signed or come from a trusted internal system
- **Network isolation**: Run workflow endpoints on private networks when possible
- **Rate limiting**: Protect against abuse even from internal systems

The generated handlers themselves don't include authentication because the security model is delegated to the world abstraction layer, allowing each runtime environment to implement the most appropriate security mechanism for its deployment context.

---

## Writing a Runtime Adapter

To integrate Workflow DevKit with a runtime, you need three components:

### Component 1: Build-Time Transformation Hook

Transform workflow files during the build/load process using the SWC plugin.

**What you need to implement:**

- A plugin/loader hook in your runtime's build system
- File filtering (typically `workflows/**/*.{ts,tsx,js,jsx}`)
- SWC transformation with `@workflow/swc-plugin`
- Module loading/resolution

**Example pattern:**

```typescript
buildSystem.plugin({
  name: "workflow-transform",
  setup(build) {
    build.onLoad(
      { filter: /workflows\/.*\.(ts|tsx|js|jsx)$/ },
      async (args) => {
        const source = await readFile(args.path);

        const result = await transform(source, {
          filename: args.path,
          jsc: {
            experimental: {
              plugins: [
                [require.resolve("@workflow/swc-plugin"), { mode: "client" }],
              ],
            },
          },
        });

        return {
          contents: result.code,
          loader: "ts",
        };
      }
    );
  },
});
```

### Component 2: HTTP Server Integration

Expose the generated workflow handlers as HTTP endpoints.

**What you need to implement:**

- HTTP server listening on a port
- Route handling for `/.well-known/workflow/v1/flow`
- Route handling for `/.well-known/workflow/v1/step`
- Importing and delegating to generated handlers

**Example pattern:**

```typescript
import flow from "./.well-known/workflow/v1/flow.js";
import step from "./.well-known/workflow/v1/step.js";

server.route("POST", "/.well-known/workflow/v1/flow", (req) => flow.POST(req));
server.route("POST", "/.well-known/workflow/v1/step", (req) => step.POST(req));
```

### Component 3: Workflow Client Integration

Import and use the Workflow DevKit client API to start workflows.

```typescript
import { start } from "workflow/api";
import { myWorkflow } from "./workflows/my-workflow.js";

const run = await start(myWorkflow, [arg1, arg2]);
console.log(run.runId);
```

---

## Reference Implementation: Bun

Here's how the three components are implemented for Bun:

### 1. Bun Plugin (Build-Time Transformation)

```typescript
import { plugin } from "bun";
import { transform } from "@swc/core";

console.log("Workflow plugin loaded");

plugin({
  name: "workflow-transform",
  setup(build) {
    build.onLoad(
      { filter: /workflows\/.*\.(ts|tsx|js|jsx)$/ },
      async (args) => {
        const source = await Bun.file(args.path).text();

        const result = await transform(source, {
          filename: args.path,
          jsc: {
            experimental: {
              plugins: [
                [require.resolve("@workflow/swc-plugin"), { mode: "client" }],
              ],
            },
          },
        });

        return {
          contents: result.code,
          loader: "ts",
        };
      }
    );
  },
});
```

**Key aspects:**

- Uses Bun's native `plugin()` API
- Filters workflow files using regex
- Uses `Bun.file()` for file reading
- Applies SWC transformation with workflow plugin
- Returns transformed code with TypeScript loader

### 2. HTTP Server (Runtime Integration)

```typescript
import { start } from "workflow/api";
import flow from "./.well-known/workflow/v1/flow.js";
import step from "./.well-known/workflow/v1/step.js";
import { handleUserSignup } from "./workflows/user-signup.js";

const server = Bun.serve({
  port: process.env.PORT,
  routes: {
    "/.well-known/workflow/v1/flow": {
      POST: (req) => flow.POST(req),
    },

    "/.well-known/workflow/v1/step": {
      POST: (req) => step.POST(req),
    },

    "/": {
      GET: async (req) => {
        const email = `test-${crypto.randomUUID()}@test.com`;

        const run = await start(handleUserSignup, [email]);

        return Response.json({
          message: "User signup workflow started",
          runId: run.runId,
        });
      },
    },
  },
});

console.log(`Server listening on http://localhost:${server.port}`);
```

**Key aspects:**

- Imports generated `flow.js` and `step.js` handlers
- Uses Bun's routing API to map endpoints
- Delegates POST requests directly to generated handlers
- Example endpoint shows how to start a workflow using `start()`

### 3. Workflow Definition

```typescript
import { sleep, FatalError } from "workflow";

export async function handleUserSignup(email: string) {
  "use workflow";

  const user = await createUser(email);
  await sendWelcomeEmail(user);

  await sendOnboardingEmail(user);

  return { userId: user.id, status: "onboarded" };
}

async function createUser(email: string) {
  "use step";

  console.log(`Creating a new user with email: ${email}`);

  return { id: crypto.randomUUID(), email };
}

async function sendWelcomeEmail(user: { id: string; email: string }) {
  "use step";

  console.log(`Sending welcome email to user: ${user.id}`);
}

async function sendOnboardingEmail(user: { id: string; email: string }) {
  "use step";

  console.log(`Sending onboarding email to user: ${user.id}`);
}
```

**Key aspects:**

- `"use workflow"` marks the main workflow function
- `"use step"` marks individual atomic operations
- Steps can be retried independently
- Return values flow between steps
- Type-safe arguments and returns
