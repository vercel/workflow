// @ts-nocheck - This file imports runtime-generated .js files
import { ChangeMessageVisibilityCommand, SQSClient } from '@aws-sdk/client-sqs';
import type { Context, SQSEvent, SQSRecord } from 'aws-lambda';

// Import the compiled workflow entrypoints
// These are generated by Next.js build and copied during Lambda build
// They follow the same pattern as Vercel's serverless functions
import { POST as flowHandler } from './.well-known/workflow/v1/flow/route.js';
import { POST as stepHandler } from './.well-known/workflow/v1/step/route.js';

/**
 * Lambda handler for processing workflow and step queue messages.
 *
 * This follows the same architecture as Vercel's workflow implementation:
 * - SQS queues trigger this Lambda (like Vercel Queue triggers functions)
 * - Messages are converted to Request objects with queue metadata
 * - The appropriate handler (flow or step) is called directly
 * - Handlers are generated by workflowEntrypoint() and stepEntrypoint()
 */
export async function handler(event: SQSEvent, context: Context) {
  console.log(
    'üî® Workflow Worker - Processing batch of',
    event.Records.length,
    'messages'
  );

  // Process workflow messages sequentially to avoid VM context race conditions
  // Steps can be processed in parallel since they don't use VM contexts
  const workflowMessages: SQSRecord[] = [];
  const stepMessages: SQSRecord[] = [];

  for (const record of event.Records) {
    const isWorkflowQueue = record.eventSourceARN?.includes('workflow-flows');
    if (isWorkflowQueue) {
      workflowMessages.push(record);
    } else {
      stepMessages.push(record);
    }
  }

  console.log(
    `üìä Batch breakdown: ${workflowMessages.length} workflows, ${stepMessages.length} steps`
  );

  // Process steps in parallel (safe)
  const stepResults = await Promise.allSettled(
    stepMessages.map((record) => processMessage(record))
  );

  // Process workflows sequentially (prevents VM context conflicts)
  const workflowResults: PromiseSettledResult<void>[] = [];
  for (const record of workflowMessages) {
    try {
      await processMessage(record);
      workflowResults.push({ status: 'fulfilled', value: undefined });
    } catch (error) {
      workflowResults.push({ status: 'rejected', reason: error });
    }
  }

  // Combine results
  const allRecords = [...stepMessages, ...workflowMessages];
  const results = [...stepResults, ...workflowResults];

  // Return failed message IDs for partial batch failure
  const batchItemFailures = results
    .map((result: PromiseSettledResult<void>, index: number) => {
      if (result.status === 'rejected') {
        console.error(
          '‚ùå Failed to process message:',
          allRecords[index].messageId,
          result.reason
        );
        return { itemIdentifier: allRecords[index].messageId };
      }
      return null;
    })
    .filter(
      (
        item: { itemIdentifier: string } | null
      ): item is { itemIdentifier: string } => item !== null
    );

  console.log(
    `‚úÖ Batch complete: ${
      results.length - batchItemFailures.length
    } succeeded, ${batchItemFailures.length} failed`
  );

  return {
    batchItemFailures,
  };
}

async function processMessage(record: SQSRecord) {
  try {
    const body = JSON.parse(record.body);
    const isWorkflowQueue = record.eventSourceARN?.includes('workflow-flows');

    console.log('üì® Processing message:', {
      messageId: record.messageId,
      type: isWorkflowQueue ? 'workflow' : 'step',
      id: body.id,
      attempt: body.attempt || 1,
      dataType: typeof body.data,
      isBuffer: Buffer.isBuffer(body.data),
      dataPreview:
        typeof body.data === 'string'
          ? body.data.substring(0, 100)
          : Buffer.isBuffer(body.data)
            ? body.data.toString('utf-8').substring(0, 100)
            : JSON.stringify(body.data).substring(0, 100),
    });

    // Construct queue name following the workflow naming convention
    const queuePrefix = isWorkflowQueue ? '__wkf_workflow_' : '__wkf_step_';
    const queueName = `${queuePrefix}${body.id}`;

    // Convert body.data from base64 to Buffer
    // body.data is now a base64-encoded string sent from Next.js
    const bodyBuffer = Buffer.from(body.data, 'base64');

    // Create a Request object with queue metadata headers
    // This matches the format expected by workflowEntrypoint/stepEntrypoint
    const request = new Request('http://lambda/__workflow', {
      method: 'POST',
      headers: {
        'content-type': 'application/json',
        'x-vqs-queue-name': queueName,
        'x-vqs-message-id': body.messageId || record.messageId,
        'x-vqs-message-attempt': String(body.attempt || 1),
      },
      body: bodyBuffer,
    });

    // Call the appropriate handler (same pattern as Vercel)
    const response = isWorkflowQueue
      ? await flowHandler(request)
      : await stepHandler(request);

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(
        `Handler returned status ${response.status}: ${errorText}`
      );
    }

    // Parse possible directive from handler
    let directive: any = null;
    try {
      const text = await response.text();
      directive = text ? JSON.parse(text) : null;
    } catch {}

    if (
      directive &&
      typeof directive.timeoutSeconds === 'number' &&
      !isWorkflowQueue
    ) {
      // For step retries, extend visibility so the message is re-delivered after delay
      const sqs = new SQSClient({ region: process.env.AWS_REGION });
      const timeout = Math.max(1, Math.min(43200, directive.timeoutSeconds));
      console.log(
        `‚è≥ Adjusting visibility for retry: ${timeout}s for message`,
        record.messageId
      );
      await sqs.send(
        new ChangeMessageVisibilityCommand({
          QueueUrl: process.env.WORKFLOW_AWS_STEP_QUEUE_URL!,
          ReceiptHandle: record.receiptHandle!,
          VisibilityTimeout: timeout,
        })
      );
      // Throw to mark partial failure so Lambda does not delete the message
      throw new Error(`Retry scheduled in ${timeout}s`);
    }

    console.log('‚úÖ Message processed successfully:', record.messageId);
  } catch (error) {
    console.error('‚ùå Error processing message:', error);
    throw error; // Re-throw to trigger SQS retry
  }
}
