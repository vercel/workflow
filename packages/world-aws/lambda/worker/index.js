// @ts-nocheck - This file imports runtime-generated .js files
// Import the compiled workflow entrypoints
// These are generated by Next.js build and copied during Lambda build
// They follow the same pattern as Vercel's serverless functions
import { POST as flowHandler } from './.well-known/workflow/v1/flow/route.js';
import { POST as stepHandler } from './.well-known/workflow/v1/step/route.js';
/**
 * Lambda handler for processing workflow and step queue messages.
 *
 * This follows the same architecture as Vercel's workflow implementation:
 * - SQS queues trigger this Lambda (like Vercel Queue triggers functions)
 * - Messages are converted to Request objects with queue metadata
 * - The appropriate handler (flow or step) is called directly
 * - Handlers are generated by workflowEntrypoint() and stepEntrypoint()
 */
export async function handler(event, context) {
  console.log(
    'üî® Workflow Worker - Processing batch of',
    event.Records.length,
    'messages'
  );
  const results = await Promise.allSettled(
    event.Records.map((record) => processMessage(record))
  );
  // Return failed message IDs for partial batch failure
  const batchItemFailures = results
    .map((result, index) => {
      if (result.status === 'rejected') {
        console.error(
          '‚ùå Failed to process message:',
          event.Records[index].messageId,
          result.reason
        );
        return { itemIdentifier: event.Records[index].messageId };
      }
      return null;
    })
    .filter((item) => item !== null);
  console.log(
    `‚úÖ Batch complete: ${
      results.length - batchItemFailures.length
    } succeeded, ${batchItemFailures.length} failed`
  );
  return {
    batchItemFailures,
  };
}
async function processMessage(record) {
  try {
    const body = JSON.parse(record.body);
    const isWorkflowQueue = record.eventSourceARN?.includes('workflow-flows');
    console.log('üì® Processing message:', {
      messageId: record.messageId,
      type: isWorkflowQueue ? 'workflow' : 'step',
      id: body.id,
      attempt: body.attempt || 1,
    });
    // Construct queue name following the workflow naming convention
    const queuePrefix = isWorkflowQueue ? '__wkf_workflow_' : '__wkf_step_';
    const queueName = `${queuePrefix}${body.id}`;
    // Create a Request object with queue metadata headers
    // This matches the format expected by workflowEntrypoint/stepEntrypoint
    const request = new Request('http://lambda/__workflow', {
      method: 'POST',
      headers: {
        'content-type': 'application/json',
        'x-vqs-queue-name': queueName,
        'x-vqs-message-id': body.messageId || record.messageId,
        'x-vqs-message-attempt': String(body.attempt || 1),
      },
      body: body.data,
    });
    // Call the appropriate handler (same pattern as Vercel)
    const response = isWorkflowQueue
      ? await flowHandler(request)
      : await stepHandler(request);
    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(
        `Handler returned status ${response.status}: ${errorText}`
      );
    }
    console.log('‚úÖ Message processed successfully:', record.messageId);
  } catch (error) {
    console.error('‚ùå Error processing message:', error);
    throw error; // Re-throw to trigger SQS retry
  }
}
