'use strict';
Object.defineProperty(exports, '__esModule', { value: true });
exports.createStreamer = void 0;
const client_s3_1 = require('@aws-sdk/client-s3');
const lib_dynamodb_1 = require('@aws-sdk/lib-dynamodb');
const ulid_1 = require('ulid');
function createStreamer(s3Client, dynamoClient, config) {
  const ulid = (0, ulid_1.monotonicFactory)();
  const tableName = config.tables.streams;
  const bucketName = config.streamBucket;
  const genChunkId = () => `chnk_${ulid()}`;
  return {
    async writeToStream(name, chunk) {
      const chunkId = genChunkId();
      const s3Key = `${name}/${chunkId}`;
      // Upload chunk data to S3
      const buffer =
        typeof chunk === 'string' ? Buffer.from(chunk) : Buffer.from(chunk);
      await s3Client.send(
        new client_s3_1.PutObjectCommand({
          Bucket: bucketName,
          Key: s3Key,
          Body: buffer,
          ContentType: 'application/octet-stream',
        })
      );
      // Store metadata in DynamoDB
      const streamChunk = {
        streamId: name,
        chunkId,
        s3Key,
        eof: false,
        createdAt: new Date().toISOString(),
      };
      await dynamoClient.send(
        new lib_dynamodb_1.PutCommand({
          TableName: tableName,
          Item: streamChunk,
        })
      );
    },
    async closeStream(name) {
      const chunkId = genChunkId();
      const s3Key = `${name}/${chunkId}`;
      // Upload empty chunk to mark EOF
      await s3Client.send(
        new client_s3_1.PutObjectCommand({
          Bucket: bucketName,
          Key: s3Key,
          Body: Buffer.from([]),
          ContentType: 'application/octet-stream',
        })
      );
      // Store EOF marker in DynamoDB
      const streamChunk = {
        streamId: name,
        chunkId,
        s3Key,
        eof: true,
        createdAt: new Date().toISOString(),
      };
      await dynamoClient.send(
        new lib_dynamodb_1.PutCommand({
          TableName: tableName,
          Item: streamChunk,
        })
      );
    },
    async readFromStream(name, startIndex) {
      return new ReadableStream({
        async start(controller) {
          let offset = startIndex ?? 0;
          let hasMore = true;
          let lastEvaluatedKey;
          while (hasMore) {
            // Query DynamoDB for chunks
            const result = await dynamoClient.send(
              new lib_dynamodb_1.QueryCommand({
                TableName: tableName,
                KeyConditionExpression: 'streamId = :streamId',
                ExpressionAttributeValues: {
                  ':streamId': name,
                },
                ExclusiveStartKey: lastEvaluatedKey,
                ScanIndexForward: true, // Sort by chunkId ascending
              })
            );
            if (!result.Items || result.Items.length === 0) {
              // No more chunks yet - in a real implementation, you might want to poll
              break;
            }
            for (const item of result.Items) {
              if (offset > 0) {
                offset--;
                continue;
              }
              // Fetch chunk data from S3
              try {
                const s3Response = await s3Client.send(
                  new client_s3_1.GetObjectCommand({
                    Bucket: bucketName,
                    Key: item.s3Key,
                  })
                );
                if (s3Response.Body) {
                  const bytes = await s3Response.Body.transformToByteArray();
                  if (bytes.length > 0) {
                    controller.enqueue(bytes);
                  }
                }
                if (item.eof) {
                  controller.close();
                  return;
                }
              } catch (error) {
                console.error(`Error reading chunk ${item.chunkId}:`, error);
                controller.error(error);
                return;
              }
            }
            lastEvaluatedKey = result.LastEvaluatedKey;
            hasMore = !!lastEvaluatedKey;
          }
          // If we get here and haven't closed, check if we should wait for more data
          // In a production implementation, you'd want to implement polling or websocket updates
          controller.close();
        },
      });
    },
  };
}
exports.createStreamer = createStreamer;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RyZWFtZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJzdHJlYW1lci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFBQSxrREFJNEI7QUFDNUIsd0RBSStCO0FBRS9CLCtCQUF3QztBQVd4QyxTQUFnQixjQUFjLENBQzVCLFFBQWtCLEVBQ2xCLFlBQW9DLEVBQ3BDLE1BQXNCO0lBRXRCLE1BQU0sSUFBSSxHQUFHLElBQUEsdUJBQWdCLEdBQUUsQ0FBQztJQUNoQyxNQUFNLFNBQVMsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQztJQUN4QyxNQUFNLFVBQVUsR0FBRyxNQUFNLENBQUMsWUFBWSxDQUFDO0lBRXZDLE1BQU0sVUFBVSxHQUFHLEdBQUcsRUFBRSxDQUFDLFFBQVEsSUFBSSxFQUFFLEVBQVcsQ0FBQztJQUVuRCxPQUFPO1FBQ0wsS0FBSyxDQUFDLGFBQWEsQ0FDakIsSUFBWSxFQUNaLEtBQTBCO1lBRTFCLE1BQU0sT0FBTyxHQUFHLFVBQVUsRUFBRSxDQUFDO1lBQzdCLE1BQU0sS0FBSyxHQUFHLEdBQUcsSUFBSSxJQUFJLE9BQU8sRUFBRSxDQUFDO1lBRW5DLDBCQUEwQjtZQUMxQixNQUFNLE1BQU0sR0FDVixPQUFPLEtBQUssS0FBSyxRQUFRLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7WUFFdEUsTUFBTSxRQUFRLENBQUMsSUFBSSxDQUNqQixJQUFJLDRCQUFnQixDQUFDO2dCQUNuQixNQUFNLEVBQUUsVUFBVTtnQkFDbEIsR0FBRyxFQUFFLEtBQUs7Z0JBQ1YsSUFBSSxFQUFFLE1BQU07Z0JBQ1osV0FBVyxFQUFFLDBCQUEwQjthQUN4QyxDQUFDLENBQ0gsQ0FBQztZQUVGLDZCQUE2QjtZQUM3QixNQUFNLFdBQVcsR0FBZ0I7Z0JBQy9CLFFBQVEsRUFBRSxJQUFJO2dCQUNkLE9BQU87Z0JBQ1AsS0FBSztnQkFDTCxHQUFHLEVBQUUsS0FBSztnQkFDVixTQUFTLEVBQUUsSUFBSSxJQUFJLEVBQUUsQ0FBQyxXQUFXLEVBQUU7YUFDcEMsQ0FBQztZQUVGLE1BQU0sWUFBWSxDQUFDLElBQUksQ0FDckIsSUFBSSx5QkFBVSxDQUFDO2dCQUNiLFNBQVMsRUFBRSxTQUFTO2dCQUNwQixJQUFJLEVBQUUsV0FBVzthQUNsQixDQUFDLENBQ0gsQ0FBQztRQUNKLENBQUM7UUFFRCxLQUFLLENBQUMsV0FBVyxDQUFDLElBQVk7WUFDNUIsTUFBTSxPQUFPLEdBQUcsVUFBVSxFQUFFLENBQUM7WUFDN0IsTUFBTSxLQUFLLEdBQUcsR0FBRyxJQUFJLElBQUksT0FBTyxFQUFFLENBQUM7WUFFbkMsaUNBQWlDO1lBQ2pDLE1BQU0sUUFBUSxDQUFDLElBQUksQ0FDakIsSUFBSSw0QkFBZ0IsQ0FBQztnQkFDbkIsTUFBTSxFQUFFLFVBQVU7Z0JBQ2xCLEdBQUcsRUFBRSxLQUFLO2dCQUNWLElBQUksRUFBRSxNQUFNLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQztnQkFDckIsV0FBVyxFQUFFLDBCQUEwQjthQUN4QyxDQUFDLENBQ0gsQ0FBQztZQUVGLCtCQUErQjtZQUMvQixNQUFNLFdBQVcsR0FBZ0I7Z0JBQy9CLFFBQVEsRUFBRSxJQUFJO2dCQUNkLE9BQU87Z0JBQ1AsS0FBSztnQkFDTCxHQUFHLEVBQUUsSUFBSTtnQkFDVCxTQUFTLEVBQUUsSUFBSSxJQUFJLEVBQUUsQ0FBQyxXQUFXLEVBQUU7YUFDcEMsQ0FBQztZQUVGLE1BQU0sWUFBWSxDQUFDLElBQUksQ0FDckIsSUFBSSx5QkFBVSxDQUFDO2dCQUNiLFNBQVMsRUFBRSxTQUFTO2dCQUNwQixJQUFJLEVBQUUsV0FBVzthQUNsQixDQUFDLENBQ0gsQ0FBQztRQUNKLENBQUM7UUFFRCxLQUFLLENBQUMsY0FBYyxDQUNsQixJQUFZLEVBQ1osVUFBbUI7WUFFbkIsT0FBTyxJQUFJLGNBQWMsQ0FBYTtnQkFDcEMsS0FBSyxDQUFDLEtBQUssQ0FBQyxVQUFVO29CQUNwQixJQUFJLE1BQU0sR0FBRyxVQUFVLElBQUksQ0FBQyxDQUFDO29CQUM3QixJQUFJLE9BQU8sR0FBRyxJQUFJLENBQUM7b0JBQ25CLElBQUksZ0JBQWlELENBQUM7b0JBRXRELE9BQU8sT0FBTyxFQUFFLENBQUM7d0JBQ2YsNEJBQTRCO3dCQUM1QixNQUFNLE1BQU0sR0FBRyxNQUFNLFlBQVksQ0FBQyxJQUFJLENBQ3BDLElBQUksMkJBQVksQ0FBQzs0QkFDZixTQUFTLEVBQUUsU0FBUzs0QkFDcEIsc0JBQXNCLEVBQUUsc0JBQXNCOzRCQUM5Qyx5QkFBeUIsRUFBRTtnQ0FDekIsV0FBVyxFQUFFLElBQUk7NkJBQ2xCOzRCQUNELGlCQUFpQixFQUFFLGdCQUFnQjs0QkFDbkMsZ0JBQWdCLEVBQUUsSUFBSSxFQUFFLDRCQUE0Qjt5QkFDckQsQ0FBQyxDQUNILENBQUM7d0JBRUYsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLElBQUksTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFLENBQUM7NEJBQy9DLHdFQUF3RTs0QkFDeEUsTUFBTTt3QkFDUixDQUFDO3dCQUVELEtBQUssTUFBTSxJQUFJLElBQUksTUFBTSxDQUFDLEtBQXNCLEVBQUUsQ0FBQzs0QkFDakQsSUFBSSxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUM7Z0NBQ2YsTUFBTSxFQUFFLENBQUM7Z0NBQ1QsU0FBUzs0QkFDWCxDQUFDOzRCQUVELDJCQUEyQjs0QkFDM0IsSUFBSSxDQUFDO2dDQUNILE1BQU0sVUFBVSxHQUFHLE1BQU0sUUFBUSxDQUFDLElBQUksQ0FDcEMsSUFBSSw0QkFBZ0IsQ0FBQztvQ0FDbkIsTUFBTSxFQUFFLFVBQVU7b0NBQ2xCLEdBQUcsRUFBRSxJQUFJLENBQUMsS0FBSztpQ0FDaEIsQ0FBQyxDQUNILENBQUM7Z0NBRUYsSUFBSSxVQUFVLENBQUMsSUFBSSxFQUFFLENBQUM7b0NBQ3BCLE1BQU0sS0FBSyxHQUFHLE1BQU0sVUFBVSxDQUFDLElBQUksQ0FBQyxvQkFBb0IsRUFBRSxDQUFDO29DQUMzRCxJQUFJLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFLENBQUM7d0NBQ3JCLFVBQVUsQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUM7b0NBQzVCLENBQUM7Z0NBQ0gsQ0FBQztnQ0FFRCxJQUFJLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQztvQ0FDYixVQUFVLENBQUMsS0FBSyxFQUFFLENBQUM7b0NBQ25CLE9BQU87Z0NBQ1QsQ0FBQzs0QkFDSCxDQUFDOzRCQUFDLE9BQU8sS0FBSyxFQUFFLENBQUM7Z0NBQ2YsT0FBTyxDQUFDLEtBQUssQ0FBQyx1QkFBdUIsSUFBSSxDQUFDLE9BQU8sR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFDO2dDQUM3RCxVQUFVLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO2dDQUN4QixPQUFPOzRCQUNULENBQUM7d0JBQ0gsQ0FBQzt3QkFFRCxnQkFBZ0IsR0FBRyxNQUFNLENBQUMsZ0JBQWdCLENBQUM7d0JBQzNDLE9BQU8sR0FBRyxDQUFDLENBQUMsZ0JBQWdCLENBQUM7b0JBQy9CLENBQUM7b0JBRUQsMkVBQTJFO29CQUMzRSx1RkFBdUY7b0JBQ3ZGLFVBQVUsQ0FBQyxLQUFLLEVBQUUsQ0FBQztnQkFDckIsQ0FBQzthQUNGLENBQUMsQ0FBQztRQUNMLENBQUM7S0FDRixDQUFDO0FBQ0osQ0FBQztBQXpKRCx3Q0F5SkMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICBHZXRPYmplY3RDb21tYW5kLFxuICBQdXRPYmplY3RDb21tYW5kLFxuICB0eXBlIFMzQ2xpZW50LFxufSBmcm9tIFwiQGF3cy1zZGsvY2xpZW50LXMzXCI7XG5pbXBvcnQge1xuICB0eXBlIER5bmFtb0RCRG9jdW1lbnRDbGllbnQsXG4gIFB1dENvbW1hbmQsXG4gIFF1ZXJ5Q29tbWFuZCxcbn0gZnJvbSBcIkBhd3Mtc2RrL2xpYi1keW5hbW9kYlwiO1xuaW1wb3J0IHR5cGUgeyBTdHJlYW1lciB9IGZyb20gXCJAd29ya2Zsb3cvd29ybGRcIjtcbmltcG9ydCB7IG1vbm90b25pY0ZhY3RvcnkgfSBmcm9tIFwidWxpZFwiO1xuaW1wb3J0IHR5cGUgeyBBV1NXb3JsZENvbmZpZyB9IGZyb20gXCIuL2NvbmZpZy5qc1wiO1xuXG5pbnRlcmZhY2UgU3RyZWFtQ2h1bmsge1xuICBzdHJlYW1JZDogc3RyaW5nO1xuICBjaHVua0lkOiBzdHJpbmc7XG4gIHMzS2V5OiBzdHJpbmc7XG4gIGVvZjogYm9vbGVhbjtcbiAgY3JlYXRlZEF0OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVTdHJlYW1lcihcbiAgczNDbGllbnQ6IFMzQ2xpZW50LFxuICBkeW5hbW9DbGllbnQ6IER5bmFtb0RCRG9jdW1lbnRDbGllbnQsXG4gIGNvbmZpZzogQVdTV29ybGRDb25maWdcbik6IFN0cmVhbWVyIHtcbiAgY29uc3QgdWxpZCA9IG1vbm90b25pY0ZhY3RvcnkoKTtcbiAgY29uc3QgdGFibGVOYW1lID0gY29uZmlnLnRhYmxlcy5zdHJlYW1zO1xuICBjb25zdCBidWNrZXROYW1lID0gY29uZmlnLnN0cmVhbUJ1Y2tldDtcblxuICBjb25zdCBnZW5DaHVua0lkID0gKCkgPT4gYGNobmtfJHt1bGlkKCl9YCBhcyBjb25zdDtcblxuICByZXR1cm4ge1xuICAgIGFzeW5jIHdyaXRlVG9TdHJlYW0oXG4gICAgICBuYW1lOiBzdHJpbmcsXG4gICAgICBjaHVuazogc3RyaW5nIHwgVWludDhBcnJheVxuICAgICk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgY29uc3QgY2h1bmtJZCA9IGdlbkNodW5rSWQoKTtcbiAgICAgIGNvbnN0IHMzS2V5ID0gYCR7bmFtZX0vJHtjaHVua0lkfWA7XG5cbiAgICAgIC8vIFVwbG9hZCBjaHVuayBkYXRhIHRvIFMzXG4gICAgICBjb25zdCBidWZmZXIgPVxuICAgICAgICB0eXBlb2YgY2h1bmsgPT09IFwic3RyaW5nXCIgPyBCdWZmZXIuZnJvbShjaHVuaykgOiBCdWZmZXIuZnJvbShjaHVuayk7XG5cbiAgICAgIGF3YWl0IHMzQ2xpZW50LnNlbmQoXG4gICAgICAgIG5ldyBQdXRPYmplY3RDb21tYW5kKHtcbiAgICAgICAgICBCdWNrZXQ6IGJ1Y2tldE5hbWUsXG4gICAgICAgICAgS2V5OiBzM0tleSxcbiAgICAgICAgICBCb2R5OiBidWZmZXIsXG4gICAgICAgICAgQ29udGVudFR5cGU6IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIsXG4gICAgICAgIH0pXG4gICAgICApO1xuXG4gICAgICAvLyBTdG9yZSBtZXRhZGF0YSBpbiBEeW5hbW9EQlxuICAgICAgY29uc3Qgc3RyZWFtQ2h1bms6IFN0cmVhbUNodW5rID0ge1xuICAgICAgICBzdHJlYW1JZDogbmFtZSxcbiAgICAgICAgY2h1bmtJZCxcbiAgICAgICAgczNLZXksXG4gICAgICAgIGVvZjogZmFsc2UsXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgfTtcblxuICAgICAgYXdhaXQgZHluYW1vQ2xpZW50LnNlbmQoXG4gICAgICAgIG5ldyBQdXRDb21tYW5kKHtcbiAgICAgICAgICBUYWJsZU5hbWU6IHRhYmxlTmFtZSxcbiAgICAgICAgICBJdGVtOiBzdHJlYW1DaHVuayxcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSxcblxuICAgIGFzeW5jIGNsb3NlU3RyZWFtKG5hbWU6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgY29uc3QgY2h1bmtJZCA9IGdlbkNodW5rSWQoKTtcbiAgICAgIGNvbnN0IHMzS2V5ID0gYCR7bmFtZX0vJHtjaHVua0lkfWA7XG5cbiAgICAgIC8vIFVwbG9hZCBlbXB0eSBjaHVuayB0byBtYXJrIEVPRlxuICAgICAgYXdhaXQgczNDbGllbnQuc2VuZChcbiAgICAgICAgbmV3IFB1dE9iamVjdENvbW1hbmQoe1xuICAgICAgICAgIEJ1Y2tldDogYnVja2V0TmFtZSxcbiAgICAgICAgICBLZXk6IHMzS2V5LFxuICAgICAgICAgIEJvZHk6IEJ1ZmZlci5mcm9tKFtdKSxcbiAgICAgICAgICBDb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIixcbiAgICAgICAgfSlcbiAgICAgICk7XG5cbiAgICAgIC8vIFN0b3JlIEVPRiBtYXJrZXIgaW4gRHluYW1vREJcbiAgICAgIGNvbnN0IHN0cmVhbUNodW5rOiBTdHJlYW1DaHVuayA9IHtcbiAgICAgICAgc3RyZWFtSWQ6IG5hbWUsXG4gICAgICAgIGNodW5rSWQsXG4gICAgICAgIHMzS2V5LFxuICAgICAgICBlb2Y6IHRydWUsXG4gICAgICAgIGNyZWF0ZWRBdDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxuICAgICAgfTtcblxuICAgICAgYXdhaXQgZHluYW1vQ2xpZW50LnNlbmQoXG4gICAgICAgIG5ldyBQdXRDb21tYW5kKHtcbiAgICAgICAgICBUYWJsZU5hbWU6IHRhYmxlTmFtZSxcbiAgICAgICAgICBJdGVtOiBzdHJlYW1DaHVuayxcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfSxcblxuICAgIGFzeW5jIHJlYWRGcm9tU3RyZWFtKFxuICAgICAgbmFtZTogc3RyaW5nLFxuICAgICAgc3RhcnRJbmRleD86IG51bWJlclxuICAgICk6IFByb21pc2U8UmVhZGFibGVTdHJlYW08VWludDhBcnJheT4+IHtcbiAgICAgIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW08VWludDhBcnJheT4oe1xuICAgICAgICBhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICAgICAgbGV0IG9mZnNldCA9IHN0YXJ0SW5kZXggPz8gMDtcbiAgICAgICAgICBsZXQgaGFzTW9yZSA9IHRydWU7XG4gICAgICAgICAgbGV0IGxhc3RFdmFsdWF0ZWRLZXk6IFJlY29yZDxzdHJpbmcsIGFueT4gfCB1bmRlZmluZWQ7XG5cbiAgICAgICAgICB3aGlsZSAoaGFzTW9yZSkge1xuICAgICAgICAgICAgLy8gUXVlcnkgRHluYW1vREIgZm9yIGNodW5rc1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgZHluYW1vQ2xpZW50LnNlbmQoXG4gICAgICAgICAgICAgIG5ldyBRdWVyeUNvbW1hbmQoe1xuICAgICAgICAgICAgICAgIFRhYmxlTmFtZTogdGFibGVOYW1lLFxuICAgICAgICAgICAgICAgIEtleUNvbmRpdGlvbkV4cHJlc3Npb246IFwic3RyZWFtSWQgPSA6c3RyZWFtSWRcIixcbiAgICAgICAgICAgICAgICBFeHByZXNzaW9uQXR0cmlidXRlVmFsdWVzOiB7XG4gICAgICAgICAgICAgICAgICBcIjpzdHJlYW1JZFwiOiBuYW1lLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgRXhjbHVzaXZlU3RhcnRLZXk6IGxhc3RFdmFsdWF0ZWRLZXksXG4gICAgICAgICAgICAgICAgU2NhbkluZGV4Rm9yd2FyZDogdHJ1ZSwgLy8gU29ydCBieSBjaHVua0lkIGFzY2VuZGluZ1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgaWYgKCFyZXN1bHQuSXRlbXMgfHwgcmVzdWx0Lkl0ZW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAvLyBObyBtb3JlIGNodW5rcyB5ZXQgLSBpbiBhIHJlYWwgaW1wbGVtZW50YXRpb24sIHlvdSBtaWdodCB3YW50IHRvIHBvbGxcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiByZXN1bHQuSXRlbXMgYXMgU3RyZWFtQ2h1bmtbXSkge1xuICAgICAgICAgICAgICBpZiAob2Zmc2V0ID4gMCkge1xuICAgICAgICAgICAgICAgIG9mZnNldC0tO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gRmV0Y2ggY2h1bmsgZGF0YSBmcm9tIFMzXG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgczNSZXNwb25zZSA9IGF3YWl0IHMzQ2xpZW50LnNlbmQoXG4gICAgICAgICAgICAgICAgICBuZXcgR2V0T2JqZWN0Q29tbWFuZCh7XG4gICAgICAgICAgICAgICAgICAgIEJ1Y2tldDogYnVja2V0TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgS2V5OiBpdGVtLnMzS2V5LFxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgaWYgKHMzUmVzcG9uc2UuQm9keSkge1xuICAgICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBhd2FpdCBzM1Jlc3BvbnNlLkJvZHkudHJhbnNmb3JtVG9CeXRlQXJyYXkoKTtcbiAgICAgICAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShieXRlcyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uZW9mKSB7XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHJlYWRpbmcgY2h1bmsgJHtpdGVtLmNodW5rSWR9OmAsIGVycm9yKTtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGFzdEV2YWx1YXRlZEtleSA9IHJlc3VsdC5MYXN0RXZhbHVhdGVkS2V5O1xuICAgICAgICAgICAgaGFzTW9yZSA9ICEhbGFzdEV2YWx1YXRlZEtleTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBJZiB3ZSBnZXQgaGVyZSBhbmQgaGF2ZW4ndCBjbG9zZWQsIGNoZWNrIGlmIHdlIHNob3VsZCB3YWl0IGZvciBtb3JlIGRhdGFcbiAgICAgICAgICAvLyBJbiBhIHByb2R1Y3Rpb24gaW1wbGVtZW50YXRpb24sIHlvdSdkIHdhbnQgdG8gaW1wbGVtZW50IHBvbGxpbmcgb3Igd2Vic29ja2V0IHVwZGF0ZXNcbiAgICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgIH0sXG4gICAgICB9KTtcbiAgICB9LFxuICB9O1xufVxuIl19
