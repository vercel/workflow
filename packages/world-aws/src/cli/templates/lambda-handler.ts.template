import { Context, SQSEvent, SQSRecord } from 'aws-lambda';

// Import the compiled workflow entrypoints
// These are generated by Next.js build and bundled with Lambda during deployment
// @ts-expect-error - These files are generated during build
import { POST as flowHandler } from '../../../app/.well-known/workflow/v1/flow/route.js';
// @ts-expect-error - These files are generated during build
import { POST as stepHandler } from '../../../app/.well-known/workflow/v1/step/route.js';

/**
 * Lambda handler for processing workflow and step queue messages.
 * 
 * Architecture:
 * - SQS queues trigger this Lambda (workflow-flows and workflow-steps)
 * - Messages are converted to Request objects with queue metadata
 * - The appropriate handler (flow or step) is called directly
 * - Handlers execute workflow/step code and update DynamoDB
 * 
 * This follows the same pattern as Vercel's workflow implementation,
 * just using AWS primitives (SQS + Lambda instead of Vercel Queue + Functions).
 */
export async function handler(event: SQSEvent, context: Context) {
  console.log(
    'üî® Workflow Worker - Processing batch of',
    event.Records.length,
    'messages'
  );

  const results = await Promise.allSettled(
    event.Records.map((record: SQSRecord) => processMessage(record))
  );

  // Return failed message IDs for partial batch failure
  const batchItemFailures = results
    .map((result: PromiseSettledResult<void>, index: number) => {
      if (result.status === 'rejected') {
        console.error(
          '‚ùå Failed to process message:',
          event.Records[index].messageId,
          result.reason
        );
        return { itemIdentifier: event.Records[index].messageId };
      }
      return null;
    })
    .filter(
      (
        item: { itemIdentifier: string } | null
      ): item is { itemIdentifier: string } => item !== null
    );

  console.log(
    `‚úÖ Batch complete: ${results.length - batchItemFailures.length} succeeded, ${batchItemFailures.length} failed`
  );

  return {
    batchItemFailures,
  };
}

async function processMessage(record: SQSRecord) {
  try {
    const body = JSON.parse(record.body);
    const isWorkflowQueue = record.eventSourceARN?.includes('workflow-flows');
    
    console.log('üì® Processing message:', {
      messageId: record.messageId,
      type: isWorkflowQueue ? 'workflow' : 'step',
      id: body.id,
      attempt: body.attempt || 1,
    });

    // Construct queue name following the workflow naming convention
    const queuePrefix = isWorkflowQueue ? '__wkf_workflow_' : '__wkf_step_';
    const queueName = `${queuePrefix}${body.id}`;

    // Create a Request object with queue metadata headers
    // This matches the format expected by workflowEntrypoint/stepEntrypoint
    const request = new Request('http://lambda/__workflow', {
      method: 'POST',
      headers: {
        'content-type': 'application/json',
        'x-vqs-queue-name': queueName,
        'x-vqs-message-id': body.messageId || record.messageId,
        'x-vqs-message-attempt': String(body.attempt || 1),
      },
      body: body.data,
    });

    // Call the appropriate handler
    const response = isWorkflowQueue
      ? await flowHandler(request)
      : await stepHandler(request);

    if (!response.ok) {
      const errorText = await response.text();
      throw new Error(
        `Handler returned status ${response.status}: ${errorText}`
      );
    }

    console.log('‚úÖ Message processed successfully:', record.messageId);
  } catch (error) {
    console.error('‚ùå Error processing message:', error);
    throw error; // Re-throw to trigger SQS retry
  }
}

